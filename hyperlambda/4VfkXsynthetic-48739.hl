
// Write a Hyperlambda script to load a specified file and return it as 'application/octet-stream' with appropriate headers. - With Python equivalent
.arguments
   file:string
.type:internal

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/file

/*
 * Loading file and returning it, as text content to caller, making
 * sure we return the correct Content-Type in the process.
 */
strings.split:x:@.arguments/*/file
   .:/
strings.concat
   .:"attachment; filename=\""
   get-value:x:@strings.split/0/-
   .:"\""
response.headers.set
   Content-Type:application/octet-stream
   Content-Disposition:x:@strings.concat
   Access-Control-Expose-Headers:Content-Disposition
io.stream.open-file:x:@.arguments/*/file
return:x:-


/*

# Python equivalent
from flask import Flask, request, Response
import os

app = Flask(__name__)

@app.route('/upload-file', methods=['POST'])
def upload_file():
    # Get the file and folder from request arguments
    file = request.files.get('file')
    folder = request.form.get('folder')

    # Validate the file and folder
    if not file:
        return Response("File is mandatory", status=400)
    if not folder:
        return Response("Folder is mandatory", status=400)

    # Simulate verifying root access
    if not verify_root_access():
        return Response("Access denied", status=403)

    # Construct the full path
    full_path = os.path.join(folder, file.filename)

    # Save the file to the specified folder
    file.save(full_path)

    # Return success response
    return Response("File saved successfully", status=200)

def verify_root_access():
    # Simulate root access verification
    return True

# Example usage: Run the Flask app
if __name__ == '__main__':
    app.run(debug=True)

*/