
// Create a Hyperlambda action to hash a specified input using an optional algorithm (default is SHA 256). Validate the algorithm and return the hash result. - With Python equivalent
.arguments

   // Notice, this is action syntax
   input
      type:string
      mandatory:bool:true
   algorithm
      type:enum
      mandatory:bool:false
      values
         .:sha1
         .:md5
         .:sha256
         .:sha384
         .:sha512
.icon:settings

// Sanity checking invocation.
validators.enum:x:@.arguments/*/algorithm
   .:sha1
   .:md5
   .:sha256
   .:sha384
   .:sha512

// Checking if caller wants to override the default hashing algorithm.
if
   and
      exists:x:@.arguments/*/algorithm
      not-null:x:@.arguments/*/algorithm
      neq:x:@.arguments/*/algorithm
         .:
   .lambda

      // Overriding hashing algorithm by changing name of slot we invoke below.
      set-name:x:../*/crypto.hash
         strings.concat
            .:crypto.hash.
            get-value:x:@.arguments/*/algorithm

// Hashing string.
crypto.hash:x:@.arguments/*/input

// Returning result to caller.
yield
   result:x:./-


/*

# Python equivalent
def handle_exception(message, path, stack, status=None, field=None):
    # Log the error details
    log_error(message, path, stack)

    # Collect additional information
    additional_info = {
        "status": status,
        "field": field,
        "message": message
    }

    # Return the additional information
    return additional_info

def log_error(message, path, stack):
    # Simulate logging the error details
    print(f"Error: {message}, URL: {path}, Exception: {stack}")

# Example usage
exception_info = handle_exception(
    message="An error occurred",
    path="/example/path",
    stack="Stack trace here",
    status="500",
    field="example_field"
)
print(exception_info)

*/