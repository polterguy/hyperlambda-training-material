
// Create a Hyperlambda script to generate and return a sitemap.xml file, setting the correct HTTP header.
.oninit

   // Applying correct HTTP Content-Type.
   response.headers.set
      Content-Type:application/xml

   // Checking if we've cached the sitemap, or if we need to create it from scratch.
   if
      not
         io.file.exists:/etc/www/.sitemap/sitemap.xml
      .lambda

         // Logging.
         log.info:Generating sitemap for site

         // Buffer for HTML files.
         .files

         // Recursively listing all HTML files we need to put into sitemap.
         io.file.list-recursively:/etc/www/
         for-each:x:@io.file.list-recursively/*

            // Verifying file should be put into sitemap.
            if
               and
                  neq:x:@.dp/#
                     .:/etc/www/sitemap.html
                  not
                     strings.ends-with:x:@.dp/#
                        .:/default.html
                  strings.ends-with:x:@.dp/#
                     .:.html
               .lambda

                  // Verifying file is not "hidden".
                  strings.substring:x:@.dp/#
                     .:int:0
                     math.subtract
                        strings.length:x:@.dp/#
                        .:int:5
                  if
                     not
                        strings.contains:x:@strings.substring
                           .:.
                     .lambda

                        // HTML file we need to create sitemap entry from
                        add:x:@.files
                           get-nodes:x:@.dp/#

         // For simplicity reasons we're just setting all dates to "now".
         .date
         date.now
         set-value:x:@.date
            date.format:x:@date.now
               format:"yyyy-MM-ddTHH:mm:ss+00:00"

         // Buffer for sitemap XML tags.
         .buffer:

         // Base URL needed to create absolute URL to sitemap URL.
         .base
         set-value:x:@.base
            strings.concat
               .:"https://"
               request.host
               .:/

         // Looping through each file we found above creating a sitemap entry for it.
         for-each:x:@.files/*

            // Removing '/etc/www/' parts.
            strings.substring:x:@.dp/#
               .:int:9

            // Removing trailing '.html' parts.
            strings.substring:x:@strings.substring
               .:int:0
               math.subtract
                  strings.length:x:@strings.substring/@strings.substring
                  .:int:5

            // Making sure index stays as root.
            if
               eq:x:@strings.substring
                  .:index
               .lambda
                  set-value:x:@strings.substring
                     strings.substring:x:@strings.substring
                        .:int:0
                        math.subtract
                           strings.length:x:@strings.substring/@strings.substring
                           .:int:5

            // Buffer for holding currently iterated URL XML tag content.
            .cur-xml
            set-value:x:@.cur-xml
               strings.concat
                  .:"  <url>\n    <loc>"
                  strings.concat
                     get-value:x:@.base
                     get-value:x:@strings.substring
                  .:"</loc>\n    <lastmod>"
                  get-value:x:@.date
                  .:"</lastmod>\n  </url>\n"

            // Concatenating currently iterated XML node(s) into [.buffer].
            set-value:x:@.buffer
               strings.concat
                  get-value:x:@.buffer
                  get-value:x:@.cur-xml

         // Now that we're done with all pages, we need to loop through all blogs.
         io.file.list:/etc/www/.blog/
         for-each:x:@io.file.list/*

            // Verifying file is Markdown.
            if
               strings.ends-with:x:@.dp/#
                  .:.md
               .lambda
                  strings.substring:x:@.dp/#
                     .:int:26
                  strings.substring:x:@strings.substring
                     .:int:0
                     math.subtract
                        strings.length:x:@strings.substring/@strings.substring
                        .:int:3

                  // Buffer for holding currently iterated URL XML tag content.
                  .cur-xml
                  set-value:x:@.cur-xml
                     strings.concat
                        .:"  <url>\n    <loc>"
                        strings.concat
                           get-value:x:@.base
                           .:blog/
                           get-value:x:@strings.substring
                        .:"</loc>\n    <lastmod>"
                        get-value:x:@.date
                        .:"</lastmod>\n  </url>\n"

                  // Concatenating currently iterated XML node(s) into [.buffer].
                  set-value:x:@.buffer
                     strings.concat
                        get-value:x:@.buffer
                        get-value:x:@.cur-xml

         // Saving file to where we expect to find it as buffered XML content.
         io.file.save:/etc/www/.sitemap/sitemap.xml
            get-value:x:@.buffer

// Returns sitemap content.
.sitemap
   io.file.load:/etc/www/.sitemap/sitemap.xml
   return:x:-
