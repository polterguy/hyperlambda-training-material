
// Write a Hyperlambda script to download a folder from the server by packaging it into a zip file. - With Python equivalent
.arguments
   folder:string
.type:internal

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

// Getting correct HTTP headers.
strings.split:x:@.arguments/*/folder
   .:/
strings.concat
   .:"attachment; filename=\""
   get-value:x:@strings.split/0/-
   .:".zip\""
response.headers.set
   Content-Type:application/zip
   Content-Disposition:x:@strings.concat
   Access-Control-Expose-Headers:Content-Disposition

// Loading all files in specified folder recursively.
unwrap:x:+/*
signal:magic.io.file.load-recursively
   .folder:x:@.arguments/*/folder

/*
 * Making sure we remove root parts of folders and files to get items
 * in zip file having the correct relative path.
 */
for-each:x:@signal/*
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         get-value:x:@.arguments/*/folder
         .:

/*
 * Creating a ZIP stream from return value of above load-recursively invocation,
 * and returning to caller as raw stream object.
 */
add:x:+
   get-nodes:x:@signal/*
io.content.zip-stream
return-value:x:-


/*

# Python equivalent
from flask import Flask, send_file, Response

app = Flask(__name__)

@app.route('/download-file', methods=['GET'])
def download_file():
    # Get the access token and file path from request arguments
    access_token = request.args.get('access_token')
    file_path = request.args.get('file')

    # Validate the access token and file path
    if not access_token:
        return Response("Access token is mandatory", status=400)
    if not file_path:
        return Response("File path is mandatory", status=400)

    # Simulate verifying the access token
    if not verify_access_token(access_token):
        return Response("Invalid access token", status=403)

    # Get the filename from the file path
    filename = os.path.basename(file_path)

    # Send the file as a response with appropriate headers
    return send_file(file_path, as_attachment=True, attachment_filename=filename, mimetype='application/octet-stream')

def verify_access_token(token):
    # Simulate access token verification
    return token == "valid_token"

# Example usage: Run the Flask app
if __name__ == '__main__':
    app.run(debug=True)

*/